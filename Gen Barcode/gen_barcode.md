# Generate Barcode

## 1. วิเคราะห์โจทย์

**โจทย์นี้เป็นโจทย์แนว Backtracking / Combinatorics (การเลือกตำแหน่ง)**  

โจทย์กำหนดให้  
- ใช้สตริงไบนารีที่ประกอบด้วย `0` และ `1`  
- ความยาวของสตริง = `B`  
- ต้องมีเลข `1` (เส้นสีขาว) **จำนวน A ตัว**  
- ที่เหลือ `B - A` ตัวเป็น `0` (เส้นสีดำ)  
- ต้องแสดงผล **ทุกความเป็นไปได้** ของสตริงที่ตรงเงื่อนไข  
- จำนวนผลลัพธ์ทั้งหมดต้องเท่ากับ `C(B, A)`

> นี่คือปัญหา “เลือกตำแหน่ง A ตำแหน่งจากทั้งหมด B ตำแหน่งให้เป็น 1”

---

## 2. แนวคิดหลัก

แนวคิดคือ  
- สร้างสตริงทีละตำแหน่งจากซ้ายไปขวา  
- ในแต่ละตำแหน่ง เรามี 2 ทางเลือก  
  - ใส่ `0` (ถ้ายังเหลือที่ให้ใส่ 0 ได้)  
  - ใส่ `1` (ถ้ายังใส่ `1` ได้ไม่เกิน A)  
- ใช้ **Recursion + Backtracking**  

**Base Case**
```cpp
if (n == 0) {
    if (one == k) all_nums.push_back(num);
    return;
}
```
- หยุด recursion เมื่อสตริงยาวครบ `B` ตัว  
  - ตรวจว่าใส่ `1` ครบ `A` ตัวหรือไม่  
  - ถ้าครบ → พิมพ์ผลลัพธ์  

**Recursive Case**
```cpp
recursive(num + "0" , n - 1 , k , one);
recursive(num + "1" , n - 1 , k , one + 1);
```
เงื่อนไขตัดกิ่ง (Pruning)
- ถ้าจำนวน `1` เกิน `A` → หยุด
- ถ้าจำนวนตำแหน่งที่เหลือไม่พอให้ใส่ `1` ครบ `A` → หยุด
---

## 3. ตัวอย่าง Test Case พร้อม Recursion Tree

### Input

```
2 5
```
หมายความว่า  
- ความยาวสตริง = 5  
- ต้องมี `1` จำนวน 2 ตัว  
- ที่เหลือเป็น `0` 

### Recursion Tree

```

                                   ""
                                    |
               ------------------------------------------------
               |                                              |
              "0"                                            "1"
               |                                              |
        --------------------                            ---------------
        |                  |                            |             |
      "00"               "01"                          "10"          "11"
        |                  |                            |             |
   ------------        ------------                ------------        |
   |          |        |          |                |          |        |
 "000"      "001"    "010"      "011"            "100"      "101"    "110"
   |          |        |          |                |          |        |
 -----     --------  --------     |             --------      |        |
 |   |     |      |  |      |     |             |      |     |        |
0000 0001 0010   0011 0100   0101 0110          1000   1001 1010     1100
 |    |     |      |    |      |    |             |      |     |        |
00011 ✓   00101 ✓ 00110 ✓   01001 ✓ 01010 ✓   01100 ✓   10001 ✓ 10010 ✓ 10100 ✓ 11000 ✓

```
✔ ใบไม้ (leaf) ที่มี `1` ครบ 2 ตัว และยาว 5 ตัว คือคำตอบทั้งหมด

### Output

```
00011
00101
00110
01001
01010
01100
10001
10010
10100
11000
```

---

## 4. อื่น ๆ

* **Time Complexity**

  * Big-O: `O(C(B, A) * B)`

### เฉลยโค้ด

```cpp
#include <iostream>
#include <vector>

using namespace std;

vector<string> all_nums;

void recursive(string num , int n , int k , int one) {

    if (n == 0) {
        if (one == k) all_nums.push_back(num);
        return;
    }

    recursive(num + "0" , n - 1 , k , one);
    recursive(num + "1" , n - 1 , k , one + 1);
}

int main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int k , n;
    cin >> k >> n;
    recursive("" , n , k , 0);
    for (auto num : all_nums) {
        cout << num << "\n";
    }
}
```