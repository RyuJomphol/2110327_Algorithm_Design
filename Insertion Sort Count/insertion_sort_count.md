# Make Zero Solution 2

## 1. วิเคราะห์โจทย์

โจทย์ข้อนี้ดูเหมือนซับซ้อนเพราะมีการอธิบาย Algorithm การเรียงลำดับแบบ Insertion Sort (แบบย้อนกลับ) ที่ยาวเหยียด แต่หัวใจสำคัญอยู่ที่คำถามครับ:

**"จะมีการทำงานบรรทัดที่ 07 (`A[i-1] = A[i]`) ทั้งหมดกี่ครั้ง โดยที่ `A[i]` เท่ากับค่า `k`"**

**มาตีความการทำงานของ Insertion Sort ในโจทย์กัน:**
* โค้ดทำงานไล่จากขวามาซ้าย (`pos` จาก `n-2` ถึง `0`)
* ตัวแปร `tmp` คือค่าทางซ้ายที่กำลังจะหาที่ลง
* ตัวแปร `A[i]` คือค่าทางขวาที่ถูกเปรียบเทียบ
* บรรทัดที่ 07 `A[i-1] = A[i]` คือการ "เลื่อนข้อมูลทางขวา ไปทางซ้าย"
* เงื่อนไขที่จะเกิดการเลื่อนคือ: `A[i] < tmp`

**สรุปตรรกะ:** ค่า `k` (ซึ่งเป็น `A[i]` ในขณะนั้น) จะถูกเลื่อนไปทางซ้าย 1 ครั้ง ก็ต่อเมื่อ **มันเจอกับตัวเปรียบเทียบทางซ้าย (`tmp`) ที่มีค่ามากกว่ามัน**

ดังนั้น แทนที่เราจะจำลองการ Sort จริงๆ ซึ่งยุ่งยาก เราสามารถนับได้เลยจาก Array เริ่มต้นว่า:

  **สำหรับค่า `k` ใดๆ จำนวนครั้งที่มันจะถูกเลื่อน (Line 07) เท่ากับ จำนวนข้อมูลที่อยู่ "ทางซ้าย" ของมัน และมีค่า "มากกว่า" มัน**

นี่จึงเป็นเหตุผลที่โค้ดคำตอบของคุณใช้แค่ `for` loop ธรรมดาเช็คเงื่อนไข `a[j] > input` ก็ได้คำตอบที่ถูกต้อง

---

## 2. แนวคิดหลัก
มาดูการทำงานของโค้ดทีละส่วน

**ส่วนประกาศตัวแปร (Global Variables):** 
 ```cpp
cin >> n >> m;         // รับขนาด Array (n) และจำนวนคำถาม (m)
vector<int> a(n);      // สร้าง vector ขนาด n
int input, k = 0;
```
* `n,m:` รับขนาด Array (n) และจำนวนคำถาม (m)
* `a(n):` สร้าง vector ขนาด n
* `input:` input คือค่า k ที่โจทย์ถาม
* `k:` คือตัวนับจำนวนครั้ง (ตั้งชื่อซ้ำกันนิดหน่อยแต่นับเป็น count)

**Loop**
```cpp
for (int i = 0 ; i < m ; i++) {
    int input, k = 0;
    cin >> input;
    for (int j = 0 ; j < n ; j++) {
        if (a[j] > input) { 
            k++;
        }
        else if (a[j] == input) {
            break;
        }
    }
    cout << k << endl;     // ปริ้นคำตอบ
}
```
* Loop ตรวจสอบสมาชิกใน Array
  * **1. ตรวจสอบตัวที่อยู่ทางซ้าย**
    * ถ้าตัวทางซ้าย "มากกว่า" ค่า input ให้บวกตัวนับเพิ่ม
    * เพราะในการ Sort จริง ค่า input จะต้องถูกเลื่อนผ่านตัวนี้ไป
  * **2. เจอตัวมันเองแล้ว**
    * หยุดทันที เพราะเราสนใจแค่ "ตัวที่อยู่ทางซ้าย" ของมันเท่านั้น
    * ตัวที่อยู่ทางขวาไม่มีผลต่อการเลื่อนของตัวนี้ใน Logic นี้
---

## 3. ตัวอย่าง Test Case

### Input

```
6 2
3 4 6 2 1 5
6 2
```
* Array `A` = `[3, 4, 6, 2, 1, 5]`
* คำถามที่ 1: `k = 6`
* คำถามที่ 2: `k = 2`

**Case 1:** `k = 6`
เราต้องการรู้ว่าเลข `6` จะถูกเลื่อนกี่ครั้ง (หรือมีตัวทางซ้ายที่มากกว่า `6` กี่ตัว)

**การทำงานของโค้ด:**

Loop เจอ `3`: น้อยกว่า 6 (ไม่นับ)
Loop เจอ `4`: น้อยกว่า 6 (ไม่นับ)
Loop เจอ `6`: เจอตัวมันเอง -> **Break**

**Output:** `0` (ถูกต้อง เพราะไม่มีตัวไหนทางซ้ายที่มากกว่า 6 เลย)

**Case 2:** k = 2
เราต้องการรู้ว่าเลข 2 จะถูกเลื่อนกี่ครั้ง

**ภาพจำลอง Array:**
```
Index:  0  1  2  3  4  5
Value: [3, 4, 6, 2, 1, 5]
                 ^
                 ตัวที่เราสนใจ (input)
```
**การทำงานของโค้ด:**

`j=0`, `a[0]=3`: **3 > 2** (จริง) -> `count = 1`
* ความหมาย: ในการ Sort, เลข 3 จะดันเลข 2 ให้ขยับไป
`j=1`, `a[1]=4`: **4 > 2** (จริง) -> `count = 2`
* ความหมาย: เลข 4 ก็จะดันเลข 2 ให้ขยับไปเช่นกัน
`j=2`, `a[2]=6`: **6 > 2** (จริง) -> `count = 3`
* ความหมาย: เลข 6 ก็จะดันเลข 2 ให้ขยับไป
`j=3`, `a[3]=2`: เจอตัวมันเอง -> **Break**
**Output:** `3`

### Output

```
0
3
```

---

## 4. อื่น ๆ

* **Time Complexity**

  * Big-O: `O(M*N)`
  * Big-Θ: `Θ(M*N)`

### เฉลยโค้ด

```cpp
#include <iostream>
#include <vector>

using namespace std;

int n,m;


int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    cin >> n >> m;
    vector<int> a(n);
    for (int i = 0 ; i < n ; i++) {
        cin >> a[i];
    }
    for (int i = 0 ; i < m ; i++) {
        int input,k = 0;
        cin >> input;
        for (int j = 0 ; j < n ; j++) {
            if (a[j] > input) {
                k++;
            }
            else if (a[j] == input) {
                break;
            }
        }
        cout << k << endl;
    }
}
```