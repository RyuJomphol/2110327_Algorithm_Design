# Inversion

## 1. วิเคราะห์โจทย์

* **โจทย์ต้องการอะไร:** นับจำนวนคู่ (i, j) ทั้งหมดที่ index ตัวหน้ามาก่อนตัวหลัง (i < j) แต่ค่าของตัวหน้า มากกว่า ค่าของตัวหลัง (A[i] > A[j]) เหตุการณ์นี้เรียกว่า "Inversion" (การกลับลำดับ)

* **วิธีที่ใช้ในโค้ด:** ใช้วิธี **Brute Force (ถึก)**
  * คือการใช้ Loop ซ้อนกัน 2 ชั้น
  * หยิบตัวเลขมาทีละตัว (v[i])
  * แล้วเอาไปไล่เปรียบเทียบกับตัวเลขที่อยู่ข้างหลังมันทุกตัว (v[j])
  * ถ้าเจอตัวหลังที่น้อยกว่า ให้นับเพิ่ม
**ข้อสังเกตสำคัญ:** วิธีนี้เข้าใจง่ายและถูกต้องในเชิงตรรกะ แต่ด้วย Input N สูงสุดถึง 100,000 (10^5) วิธีนี้อาจจะทำงานไม่ทันเวลา (Time Limit Exceeded) ใน Test Case ใหญ่ๆ เดี๋ยวเราจะคุยเรื่องนี้ในส่วน Big O ครับ (แต่ Grader นี้รันผ่านได้)

---

## 2. แนวคิดหลัก
มาดูการทำงานของโค้ดทีละส่วน

**รับค่า N:**
```
int N;
cin >> N;
```

* รับขนาดของอาร์เรย์

**รับค่าสมาชิกในอาร์เรย์:**
```
vector<int> v(N);
for (int i = 0 ; i < N ; i++) {
    cin >> v[i];
}
```
* สร้าง vector<int> v(N); และใช้ Loop for รับค่าตัวเลขเก็บลงใน Vector ทีละตำแหน่ง

**ประมวลผล (Core Logic):** 
```
int count = 0;
for (int i = 0 ; i < v.size() ; i++) {
    for (int j = i ; j < v.size() ; j++) {
        if (v[i] > v[j]) count++;
    }
}
```
  * `int count = 0;`: ตัวแปรสำหรับนับจำนวน Inversion
  * Outer Loop (`i`): `for (int i = 0 ; i < v.size() ; i++)`
    * ทำหน้าที่เป็นตัวตั้ง (ตัวหน้า) ไล่ตั้งแต่ตัวแรกถึงตัวสุดท้าย
  * Inner Loop (`j`): `for (int j = i ; j < v.size() ; j++)`
    * ทำหน้าที่เป็นตัวเปรียบเทียบ (ตัวหลัง)
    * หมายเหตุ: ตามนิยาม i < j ดังนั้น Loop นี้ควรเริ่มที่ `int j = i + 1` จะตรงตามนิยามและประหยัดรอบกว่า (แต่เริ่มที่ i ก็ไม่ผิด เพราะตัวมันเองจะไม่มากกว่าตัวมันเอง เงื่อนไขจึงเป็นเท็จอยู่ดี)
  * Condition: `if (v[i] > v[j]) count++;`
    * ถ้ารู้ว่า "ตัวหน้า (i) มีค่ามากกว่า ตัวหลัง (j)" ให้นับเป็น 1 Inversion

## 3. ตัวอย่าง Test Case

### Input

```
4
10 30 40 20
```
**ขั้นตอนการทำงาน (Step-by-Step Visualization):**
**รอบที่ 1: `i = 0` (ค่า 10)** เปรียบเทียบ 10 กับตัวข้างหลังทั้งหมด:
* `j=1` (30): 10 > 30? -> `False`
* `j=2` (40): 10 > 40? -> `False`
* `j=3` (20): 10 > 20? -> `False`
* **Count = 0**
**รอบที่ 2: `i = 1` (ค่า 30)** เปรียบเทียบ 30 กับตัวข้างหลัง:
* `j=2` (40): 30 > 40? -> `False`
* `j=3` (20): 30 > 20? -> `True` (เจอคู่ 30, 20)
* **Count = 0 + 1 = 1**
**รอบที่ 3: `i = 2` (ค่า 40)** เปรียบเทียบ 40 กับตัวข้างหลัง:
* `j=3` (20): 40 > 20? -> `True` (เจอคู่ 40, 20)
* `Count = 1 + 1 = 2`
**รอบที่ 4: `i = 3` (ค่า 20)** 
* ไม่มีตัวหลังให้เทียบ (Inner loop จบทันที)

### Output

```
2
```

---

## 4. อื่น ๆ

* **Time Complexity**

  * Big-O: `O(N^2)`

### เฉลยโค้ด

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int N;
    cin >> N;
    vector<int> v(N);
    for (int i = 0 ; i < N ; i++) {
        cin >> v[i];
    }
    int count = 0;
    for (int i = 0 ; i < v.size() ; i++) {
        for (int j = i ; j < v.size() ; j++) {
            if (v[i] > v[j]) count++;
        }
    }
    cout << count << endl;
}
```