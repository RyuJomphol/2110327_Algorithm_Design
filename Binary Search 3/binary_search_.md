# Binary Search 3

## 1. วิเคราะห์โจทย์

**โจทย์ต้องการอะไร:** เราได้รับอาร์เรย์ที่เรียงลำดับมาแล้ว (Sorted Array) และต้องตอบคำถาม $M$ ครั้ง โดยแต่ละครั้งจะได้รับค่า $X_i$ เป้าหมายคือ **"หา Index ที่มากที่สุด ที่ค่าในตำแหน่งนั้นไม่เกิน** $X_i$" (พูดง่ายๆ คือหาตัวเลขที่ $\le X_i$ ที่อยู่ทางขวาสุด) ถ้าไม่มีเลยให้ตอบ -1

**ทำไมต้องใช้ Binary Search:**
* **ข้อจำกัดเวลา:** โจทย์ให้เวลา 1 วินาที กับข้อมูล $N, M$ สูงถึง $100,000$
* **Linear Search** ($O(N)$): ถ้าเราวนลูปหาทีละตัว $M$ ครั้ง จะใช้เวลา $O(M \times N)$ ซึ่งอาจสูงถึง $10^{10}$ รอบ (Time Limit Exceeded แน่นอน)
* **Binary Search** ($O(\log N)$): เนื่องจากข้อมูล **"เรียงลำดับมาแล้ว"** เราสามารถแบ่งครึ่งข้อมูลเพื่อค้นหาได้ การทำ Binary Search $M$ ครั้งจะใช้เวลาเพียง $O(M \log N)$ ซึ่งทันเวลาแน่นอน

**เทคนิคเฉพาะในโค้ดนี้:**นี่ไม่ใช่ Binary Search แบบปกติที่หาค่าเท่ากับเป้าหมาย แต่เป็นการหา **Upper Bound** (ขอบเขตบน) หรือค่าที่มากที่สุดที่ยังตรงตามเงื่อนไข ($\le K$) โค้ดนี้ใช้เทคนิคการขยับ `low` และ `high` แบบเฉพาะเพื่อให้ได้ index ขวาสุด

---

## 2. แนวคิดหลัก
โค้ดนี้ใช้เทคนิค Binary Search เพื่อหา "คำตอบที่ดีที่สุด" (ตำแหน่งขวาสุดที่เป็นไปได้)

**ส่วนฟังก์ชัน** `find_num(int k):`
* **การตั้งค่าขอบเขต** (`low`, `high`):
  * `int low = -1;`: ให้เริ่มที่ -1 เพื่อรองรับกรณีที่ไม่มีคำตอบเลย (ค่า $k$ น้อยกว่าทุกตัวใน Array)
  * `int high = N - 1;`: ขอบเขตขวาสุดคือตัวสุดท้ายของ Array
```cpp
int find_num(int k) {
    int low = -1;
    int high = N - 1;
    //...
```
* **ลูปการค้นหา** (`while (low < high)`):
  * ลูปจะทำงานตราบใดที่ขอบเขตล่างยังไม่ชนกับขอบเขตบน
  * **การหาค่ากลาง:** `int middle = (low + high + 1) / 2;`
    * *จุดสังเกต:* มีการ `+1` ก่อนหาร 2 เพื่อปัดเศษขึ้น (Ceiling) การทำแบบนี้ป้องกัน "Infinite Loop" ในกรณีที่ `low` และ `high` อยู่ติดกัน (เช่น low=0, high=1 ถ้าไม่บวก 1 `middle` จะได้ 0 ซึ่งทำให้ `low` ไม่ขยับ)
```cpp
while (low < high) {
        int middle = (low + high + 1) / 2;
        //...
```
* **การตรวจสอบเงื่อนไข:**
  * `if (v[middle] <= k)`:
    * ถ้าค่าตรงกลาง **น้อยกว่าหรือเท่ากับ** $k$ แปลว่าตัวนี้ "**อาจจะเป็นคำตอบ**" หรือคำตอบอาจจะอยู่ทางขวาอีก (ค่าที่มากกว่านี้แต่ยัง $\le k$)
    * ดังนั้นเราขยับ `low = middle` (เก็บตำแหน่งนี้ไว้ ไม่ข้ามไป `middle + 1` เพราะตัวนี้อาจจะดีที่สุดแล้ว)
  * `else` (`v[middle] > k`):
    * ถ้าค่าตรงกลาง **มากกว่า** $k$ แปลว่าตัวนี้และทางขวาทั้งหมดใช้ไม่ได้
    * ดังนั้นเราตัดทิ้งโดยขยับ `high = middle - 1`
```cpp
if (v[middle] <= k) {
    low = middle;
}
else {
    high = middle - 1;
}
```
* **คืนค่า:**
  * เมื่อลูปจบ (`low == high`), ตัวแปร `high` (หรือ `low`) จะชี้ไปที่ Index ที่มากที่สุดที่มีค่า $\le k$ หรือเป็น -1 ถ้าไม่มี
```cpp
return high;
```

**ส่วน** `main`:
* รับค่า $N, M$ และรับ Array เข้ามาเก็บใน `vector<int> v`
* วนลูปรับค่า Query (`num2`) และเรียก `find_num`
* พิมพ์ค่า index นั้น (`idx`)
```cpp
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cin >> N >> M;
    v.resize(N);
    for(int i = 0 ; i < N ; i++) {
        cin >> num1;
        v[i] = num1;
    }
    while(M--) {
        cin >> num2;
        int idx = find_num(num2);
        cout << idx << endl; 
    }
}
```

## 3. ตัวอย่าง Test Case

### Input

```
10 8
10 13 14 14 14 15 16 16 18 200
9 10 11 14 0 200 20 16
```

**Array** `v`:
| Index | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 
| :--- | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | 
| Val | 10 | 13 | 14 | 14 | 14 | 15 | 16 | 16 | 18 | 200 |

**ตัวอย่างการ Trace: Query** `14` **(ต้องการหา index ขวาสุดของเลข 14)**
เป้าหมาย: หาเลขที่ $\le 14$

**ขั้นตอนการทำงาน (Algorithm Trace):**
* **Start:** `low = -1`, `high = 9`
  * `mid` = $(-1 + 9 + 1) / 2 = 4$
  * `v[4]` คือ **14**
  * เงื่อนไข `14 <= 14` เป็นจริง -> ขยับ `low = 4` (เก็บตำแหน่ง 4 ไว้ แล้วดูว่ามีดีกว่านี้ทางขวาไหม)
* **Iter 2:** `low = 4`, `high = 9`
  * `mid` = $(4 + 9 + 1) / 2 = 7$
  * `v[7]` คือ **16**
  * เงื่อนไข `16 <= 14` เป็นเท็จ (เกินค่าที่ต้องการ) -> ตัดขวาทิ้ง ขยับ `high = 6`
* **Iter 3:** `low = 4`, `high = 6`
  * `mid` = $(4 + 6 + 1) / 2 = 5$
  * `v[5]` คือ **15**
  * เงื่อนไข `15 <= 14` เป็นเท็จ -> ตัดขวาทิ้ง ขยับ `high = 4`
* **End:** `low = 4`, `high = 4`
  * Loop จบ (`low < high` เป็นเท็จ)
  * **Return: 4**

**ตรวจสอบ Output ทั้งหมด**
* **Query 9:** ค่าน้อยกว่าตัวต่ำสุดใน array -> `low` จะอยู่ที่ -1 ตลอด -> ตอบ **-1**
* **Query 10:** เท่ากับตัวแรก (idx 0) -> ตอบ **0**
* **Query 11:** 10 น้อยกว่า 11 (idx 0) -> ตอบ **0**
* **Query 14:** ตัวขวาสุดที่เป็น 14 คือ idx 4 -> ตอบ **4**
* **Query 0:** น้อยกว่าทุกตัว -> ตอบ **-1**
* **Query 200:** เจอตัวสุดท้าย (idx 9) -> ตอบ **9**
* **Query 20:** มากสุดที่ไม่เกิน 20 คือ 18 (idx 8) -> ตอบ **8**
* **Query 16:** ตัวขวาสุดที่เป็น 16 คือ idx 7 -> ตอบ **7**

### Output

```
-1
0
0
4
-1
9
8
7
```

---

## 4. อื่น ๆ

* **Time Complexity**

  * Big-O: `$$O(M \log N)$$`

### เฉลยโค้ด

```cpp
#include <iostream>
#include <vector>

using namespace std;

int N,M,num1,num2;
vector<int> v;

int find_num(int k) {
    int low = -1;
    int high = N - 1;
    while (low < high) {
        int middle = (low + high + 1) / 2;
        if (v[middle] <= k) {
            low = middle;
        }
        else {
            high = middle - 1;
        }
    }
    return high;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cin >> N >> M;
    v.resize(N);
    for(int i = 0 ; i < N ; i++) {
        cin >> num1;
        v[i] = num1;
    }
    while(M--) {
        cin >> num2;
        int idx = find_num(num2);
        cout << idx << endl; 
    }
}
```