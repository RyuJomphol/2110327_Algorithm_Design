# Larger Restaurant

## 1. วิเคราะห์โจทย์

โจทย์ข้อนี้จัดอยู่ในประเภท **Binary Search on Answer (การค้นหาคำตอบแบบทวิภาค)**

ให้ลองเปลี่ยนมุมมองจาก "ลูกค้าคนที่ C จะได้นั่งตอนเวลากี่โมง?" เป็นคำถามกลับกันว่า:"**ณ เวลา T มีลูกค้าได้นั่งไปแล้วกี่คน?**"

สมมติเรามีฟังก์ชัน `check(time)` เพื่อคำนวณจำนวนลูกค้า:
* ถ้าเวลาผ่านไปน้อยๆ -> จำนวนลูกค้าที่ได้นั่งก็น้อย
* ถ้าเวลาผ่านไปนานๆ -> จำนวนลูกค้าที่ได้นั่งก็เยอะ

จะเห็นว่าความสัมพันธ์ระหว่าง "เวลา" กับ "จำนวนลูกค้า" เป็นกราฟที่เพิ่มขึ้นตลอด (Monotonic function) ลักษณะนี้เหมาะที่สุดสำหรับการใช้ **Binary Search** เพื่อหาเวลาที่น้อยที่สุดที่จำนวนลูกค้า >= C ครับ

**แนวคิดทางคณิตศาสตร์**
สมมติเราอยากรู้ว่า ณ เวลา `time` เชฟแต่ละคนรับลูกค้าไปแล้วกี่คน?
* เชฟคนที่ i ทำอาหารเสร็จทุกๆ T_i นาที
* ที่เวลา 0 นาที เชฟทุกคนรับลูกค้าคนแรกทันที (จำนวน 1 คน)
* ที่เวลา T_i นาที เชฟรับลูกค้าคนที่ 2
* ที่เวลา 2 x T_i นาที เชฟรับลูกค้าคนที่ 3
* ...
* ดังนั้น ณ เวลา `time` เชฟคนที่ i จะรับลูกค้าไปแล้วจำนวน:
$$\text{count}_i = \left\lfloor \frac{\text{time}}{T_i} \right\rfloor + 1$$ 
  *(บวก 1 เพราะรวมคนแรกที่นั่งตอนเวลา 0 ด้วย)*

**จำนวนลูกค้ารวมทั้งหมด ณ เวลา `time` คือ:**
$$\text{Total}(time) = \sum_{i=1}^{N} \left( \left\lfloor \frac{\text{time}}{T_i} \right\rfloor + 1 \right)$$

**ขั้นตอนการเขียนโค้ด (Algorithm)** 
* **กำหนดช่วงการค้นหา (Range):**
  * ค่าต่ำสุด (L) = 0 (เวลาเริ่มเปิดร้าน)
  * ค่าสูงสุด (R) = 10^15 (เผื่อไว้ให้เยอะที่สุด เพราะลูกค้า 10^12 คน ถ้าเจอเชฟช้าสุด 1000 นาที อาจใช้เวลามากถึง 10^15 นาที) *ต้องใช้ตัวแปรชนิด 64-bit integer (long long ใน C++)*
* **เริ่มกระบวนการ Binary Search:**
  * หาจุดกึ่งกลาง `mid = (L + R) / 2`
  * คำนวณว่า ณ เวลา `mid` มีลูกค้านั่งไปแล้วกี่คน (ใช้สูตร Sigma ด้านบน)
  * `ตรวจสอบเงื่อนไข:`
    * ถ้า `จำนวนคน` >= C: แปลว่าเวลา `mid` นี้อาจจะเป็นคำตอบ หรือคำตอบอาจจะอยู่ก่อนหน้านี้ก็ได้ ให้ขยับขอบขวาลงมา (R = mid)
    * ถ้า `จำนวนคน < C: แปลว่าเวลายังน้อยไป ลูกค้าคนที่ C ยังไม่ได้นั่ง ให้ขยับขอบซ้ายขึ้นไป (L = mid + 1)
  * ทำซ้ำจนกว่า L จะชนกับ R
* **คำตอบ:** ค่า L (หรือ R) ที่เหลืออยู่คือเวลาที่น้อยที่สุดที่ลูกค้าคนที่ C ได้นั่งพอดี

---

## 2. แนวคิดหลัก
มาดูการทำงานของโค้ดทีละส่วน

```
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// ใช้ long long เพราะค่าเวลาและลำดับลูกค้าเกิน 2 พันล้าน (32-bit ไม่พอ)
typedef long long ll;

int main() {
    // 1. อ่านค่า N และ A
    int N, A;
    if (!(cin >> N >> A)) return 0;

    // 2. อ่านค่าเวลาของเชฟแต่ละคน
    vector<ll> T(N);
    for (int i = 0; i < N; i++) {
        cin >> T[i];
    }

    // 3. อ่านคำถาม (ลำดับลูกค้าที่ต้องการรู้)
    vector<ll> customers(A);
    for (int i = 0; i < A; i++) {
        cin >> customers[i];
    }

    // 4. ประมวลผลแต่ละคำถามด้วย Binary Search
    for (int k = 0; k < A; k++) {
        ll target_customer = customers[k];
        
        // ขอบเขตของเวลา: 0 ถึง ค่ามาก ๆ (1e14 เป็นค่าที่ปลอดภัยสำหรับโจทย์นี้)
        ll low = 0, high = 2e14; 
        ll ans = high;

        while (low <= high) {
            ll mid = low + (high - low) / 2;
            
            // คำนวณจำนวนคนที่นั่งได้ ณ เวลา mid
            ll total_seated = 0;
            for (int i = 0; i < N; i++) {
                total_seated += (mid / T[i]) + 1;
            }

            // ตรวจสอบเงื่อนไข
            if (total_seated >= target_customer) {
                ans = mid;      // เวลา mid เป็นไปได้ เก็บคำตอบไว้
                high = mid - 1; // ลองหาเวลาที่น้อยกว่านี้
            } else {
                low = mid + 1;  // เวลา mid น้อยไป ต้องเพิ่มเวลา
            }
        }
        
        cout << ans << "\n";
    }

    return 0;
}
```

## 3. ตัวอย่าง Test Case

### Input

```
3 5
2 2 5
4 5 6 30 123456789012
```
**ข้อมูลนำเข้า (Input)**
* **จำนวนเชฟ (N)**: 3 คน
* **เวลาทำอาหาร (T_i)**:
  * เชฟคนที่ 1: `2` นาที
  * เชฟคนที่ 2: `2` นาที
  * เชฟคนที่ 3: `5` นาที
* ลูกค้าที่ต้องการรู้ (C): `4`, `5`, `6`, `30`, `123456789012`

**ตัวอย่างที่ ลูกค้าคนที่ 30 (C = 30) - จำลอง Binary Search**
สมมติกำหนดขอบเขต `Low = 0`, `High = 60` (เดาจาก 30 x 2)
* **รอบที่ 1:** `Mid = (0+60)/2 = 30`
  * เชฟ 1: (30/2)+1 = 16
  * เชฟ 2: (30/2)+1 = 16
  * เชฟ 3: (30/5)+1 = 7
  * รวม: 16+16+7 = 39 คน (>= 30)
  * เก็บคำตอบ `Ans = 30`, ปรับ `High = 29` (ลองหาเวลาน้อยกว่านี้)
* **รอบที่ 2:** `Mid = (0+29)/2 = 14`
  * รวม: (14/2+1) x 2 + (14/5+1) = 8+8+3 = 19 คน (< 30)
  * คนน้อยไป ปรับ `Low = 15`
* **...ข้ามไปรอบท้ายๆ...** ลองเช็คที่ **23** และ **24**
  * **ที่ T = 23:**
    * (11+1) + (11+1) + (4+1) = 12+12+5 = 29 คน (ขาด 1 คน)
  * **ที่ T = 24:**
    * (12+1) + (12+1) + (4+1) = 13+13+5 = 31 คน (ครบแล้ว!)**คำตอบของลูกค้าคนที่ 30 คือ เวลา 24**

### Output

```
2
2
4
24
102880657508
```

---

## 4. อื่น ๆ

* **Time Complexity**

  * Big-O: `O(N)`
  * Big-Θ: `Θ(N)`

### เฉลยโค้ด

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

typedef long long ll;

int main() {
    int N, A;
    if (!(cin >> N >> A)) return 0;

    vector<ll> T(N);
    for (int i = 0; i < N; i++) {
        cin >> T[i];
    }

    vector<ll> customers(A);
    for (int i = 0; i < A; i++) {
        cin >> customers[i];
    }

    for (int k = 0; k < A; k++) {
        ll target_customer = customers[k];
        
        ll low = 0, high = 2e14; 
        ll ans = high;

        while (low <= high) {
            ll mid = low + (high - low) / 2;
            
            ll total_seated = 0;
            for (int i = 0; i < N; i++) {
                total_seated += (mid / T[i]) + 1;
            }

            if (total_seated >= target_customer) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        
        cout << ans << "\n";
    }

    return 0;
}
```