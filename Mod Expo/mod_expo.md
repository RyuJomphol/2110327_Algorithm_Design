# Mod Expo

## 1. วิเคราะห์โจทย์

โจทย์ต้องการให้หาค่าของ $X^N \pmod K$

**ความท้าทาย (Constraints):**
* ค่า $N$ มีค่าได้สูงสุดถึง $2^{31}$ (ประมาณ 2,000 ล้าน)
* **วิธีตรงไปตรงมา (Naive Approach):** หากเราวนลูปคูณ $X$ จำนวน $N$ รอบ จะใช้เวลาคำนวณนานเกิน Time Limit (1 วินาที รองรับได้ประมาณ $10^8$ คำสั่ง แต่ $N$ มีค่าระดับ $10^9$) และค่าผลลัพธ์ของ $X^N$ จะมหาศาลจนตัวแปรเก็บไม่ไหว (Integer Overflow)
* **วิธีที่ถูกต้อง:** ต้องใช้เทคนิค **Modular Exponentiation** (หรือ Binary Exponentiation / Exponentiation by Squaring)

**หลักการทำงาน:** แทนที่จะคูณทีละ 1 ครั้ง ($X \cdot X \cdot X \dots$) เราจะใช้วิธี **"การยกกำลังสอง"** (Squaring) เพื่อลดจำนวนรอบการทำงานลงเหลือเพียง $\log_2 N$ รอบ และใช้คุณสมบัติของ Modulo ที่โจทย์ให้มา:

$$(A \cdot B) \pmod K = ((A \pmod K) \cdot (B \pmod K)) \pmod K$$

เพื่อควบคุมให้ตัวเลขไม่เกินค่า $K$ ตลอดการคำนวณ

---

## 2. แนวคิดหลัก

โค้ดที่ให้มาใช้ฟังก์ชัน `power` ในการคำนวณ มาดูการทำงานทีละส่วนครับ:

```cpp
long long power(long long x, long long n, long long k) {
    long long res = 1;      // 1. กำหนดผลลัพธ์เริ่มต้นเป็น 1 (Identity ของการคูณ)
    x = x % k;              // 2. ลดรูป x ให้ไม่เกิน k ตั้งแต่เริ่ม (Optimization)

    while (n > 0) {         // 3. วนลูปจนกว่าค่าเลขชี้กำลัง (n) จะหมด
        if (n % 2 == 1) {   // 4. ตรวจสอบว่า n เป็นเลขคี่หรือไม่ (หรือเช็ค bit ขวาสุดว่าเป็น 1)
            res = (res * x) % k; // 5. ถ้าใช่ ให้คูณค่า x ปัจจุบันเข้าไปที่ผลลัพธ์
        }
        x = (x * x) % k;    // 6. เพิ่มค่า x เป็นกำลังสอง (เตรียมไว้สำหรับ bit ถัดไป)
        n = n / 2;          // 7. หาร n ครึ่งหนึ่ง (Shift bit ไปทางขวา)
    }
    return res;             // 8. คืนค่าผลลัพธ์
};
```

**คำอธิบายเพิ่มเติม:** ตัวแปร `M` ใน `main()` ทำหน้าที่เป็นค่า `N` (เลขชี้กำลัง) ตามโจทย์

---

## 3. ตัวอย่าง Test Case

### Input

```
123 4727 153
```

* $X = 123$
* $N = 4727$
* $K = 153$
* **เป้าหมาย:** $123^{4727} \pmod{153}$

**ภาพรวมขั้นตอน (Visual Logic)**
หลักการคือเราจะมอง $N$ (4727) ในรูปแบบ **เลขฐานสอง (Binary):**

$$4727_{10} = 1001001110111_2$$

อัลกอริทึมจะทำงานจากขวาไปซ้าย (Bit ต่ำสุดไปสูงสุด) ถ้าเจอเลข `1` จะเอาค่า $X$ ณ รอบนั้นมาคูณใส่คำตอบ

**ตารางการทำงาน (Execution Trace)**
เพื่อความเข้าใจง่าย ผมจะแสดงเฉพาะรอบที่มีการเปลี่ยนแปลงสำคัญ (เฉพาะรอบที่ $N$ เป็นเลขคี่ ซึ่งจะส่งผลต่อ `res`)

|รอบที่ | ค่า N (Decimal) | N เป็นคี่? | การกระทำกับ Result (res) | ค่า X (ฐาน) ในรอบถัดไป (X2(modK))
| ---- | ---- | ---- | ---- | ---- |
|Start | 4727 | Yes | res = (1 * 123) % 153 -> 123 | $123^2 \pmod{153} = 135$
|2 | 2363 | Yes |res = (123 * 135) % 153 -> 81 | $135^2 \pmod{153} = 18$
| 3 | 1181 | Yes | res = (81 * 18) % 153 -> 81 | $18^2 \pmod{153} = 18$
| 4 | 590 | No | (ไม่มีการคูณ res) | $18^2 \pmod{153} = 18$
| 5| 295 | Yes | res = (81 * 18) % 153 -> 81 | $18^2 \pmod{153} = 18$
| 6| 147 | Yes | res = (81 * 18) % 153 -> 81| $18^2 \pmod{153} = 18$
|7 |73 | Yes | res = (81 * 18) % 153 -> 81 | $18^2 \pmod{153} = 18$
|... | ... | ... | (ทำซ้ำกระบวนการ) |...
|End | 0 | -| Final Result = 81 | -

```
N = 4727 (Binary: ...10111)
          |
          v
+-------+---+--------------------------+
| Bit=1 | 1 |  Res = Res * X           | <--- คูณเก็บไว้
+-------+---+--------------------------+
|       |   |  X becomes X * X         | <--- เบิ้ลค่า X เป็น 2 เท่าเสมอ
| Bit=1 | 1 |  Res = Res * X (New)     |
+-------+---+--------------------------+
|       |   |  X becomes X * X         |
| Bit=1 | 1 |  Res = Res * X (New)     |
+-------+---+--------------------------+
|       |   |  X becomes X * X         |
| Bit=0 | 0 |  (Skip Multiply)         | <--- ข้ามการคูณ
+-------+---+--------------------------+
      ... ทำจน N = 0
```

### Output

```
81
```

---

## 4. อื่น ๆ

* **Time Complexity**

  * Big-O: $O(\log N)$

### เฉลยโค้ด

```cpp
#include <iostream>
#include <vector>

using namespace std;

long long power(long long x, long long n, long long k) {
    long long res = 1;
    x = x % k;

    while (n > 0) {
        if (n % 2 == 1) {
            res = (res * x) % k;
        }
        x = (x * x) % k;
        n = n / 2;
    }
    return res;
};

int main() {
    long long X,M,K;
    cin >> X >> M >> K;
    long long result = power(X,M,K);
    cout << result << endl;
}
```