# Make Zero Solution 1

## 1. วิเคราะห์โจทย์

**หัวใจของโจทย์:** โจทย์ต้องการให้เราทำให้ค่า x กลายเป็น 0 ภายใต้ระบบ **Modulo** 16777216 สิ่งที่ต้องสังเกตคือตัวเลข 16777216 นั้นมีค่าเท่ากับ 2^24 พอดี

**การดำเนินการ (Operations):**
* **Add 1:** x = x + 1
* **Multiply by 2:** x = x * 2 (ในทางคอมพิวเตอร์ การคูณ 2 คือการ **Left Shift** บิตไปทางซ้าย 1 ครั้ง)

**กลยุทธ์การแก้ปัญหา (Solution Strategy):** เพื่อให้ x กลายเป็น 0 ใน mod 2^24 แปลว่าค่าของ x จะต้องถูกทำให้เป็น พหุคูณของ 2^24

แทนที่เราจะสุ่มทำ Operation เราสามารถมองย้อนกลับหรือทดลองได้ดังนี้:
* เราสามารถเลือกทำ **คูณ 2 (Shift)** จำนวน j ครั้ง (โดยที่ 0 <= j <= 24) 
* ถ้าเราตัดสินใจว่าจะคูณ 2 จำนวน j ครั้ง แปลว่าค่าตั้งต้นก่อนคูณ จะต้องหาร 2^(24-j) ลงตัว
* ดังนั้น เราจึงคำนวณหาว่า ต้อง **บวก 1 (Add)** อีกกี่ครั้ง (i) เพื่อให้ค่า x หาร 2^(24-j) ลงตัว
* คำตอบของแต่ละกรณีคือ i + j แล้วเราเลือกค่าที่น้อยที่สุด (Minimum)

อัลกอริทึมนี้จึงเป็นการ **วนลูปตรวจสอบจำนวนการ Shift ที่เป็นไปได้ทั้งหมด (0 ถึง 24 ครั้ง)** แล้วดูว่าทางเลือกไหนใช้การบวกน้อยที่สุด

---

## 2. แนวคิดหลัก
มาดูการทำงานของโค้ดทีละส่วน

**ส่วนประกาศตัวแปร (Global Variables):** 
 ```cpp
long long x;
int min_ops = 24;
const int MOD_VAL = 16777216;
```
* `x:` เป็นเลขที่เราต้องการในการทำ Operation
* `min_ops:` ค่าเริ่มต้นของคำตอบ (กรณีแย่สุดคือ Shift 24 ครั้งเพื่อดันบิตทิ้งทั้งหมด)
* `MOD_VAL:` ค่าที่เราต้องการ mod

**Special Case**
```cpp
if (x == 0) {
    cout << 0 << endl;
    return 0;
}
```
* ถ้า `x` เป็น `0` อยู่แล้ว ไม่ต้องทำอะไรเลย ตอบ `0`

**Loop**
```cpp
for (int j = 0; j <= 24; j++) {
    // divisor คือ 2 ยกกำลัง (24 - j)
    // ใช้ Bitwise shift (1 << n) เพื่อหาค่า 2^n
    // ยิ่งเรา Shift (คูณ 2) เยอะ (j มาก) ตัวหารที่ต้องการ (divisor) ก็จะยิ่งน้อยลง
    int divisor = 1 << (24 - j); 

    // หาเศษเหลือว่าตอนนี้ x ขาดอีกเท่าไหร่ถึงจะหาร divisor ลงตัว
    int remainder = x % divisor;

    // i คือจำนวนครั้งที่ต้อง "บวก 1"
    // ถ้าหารลงตัวอยู่แล้ว i = 0
    // ถ้าไม่ลงตัว ต้องบวกเพิ่มเท่ากับ (ตัวหาร - เศษ)
    int i = (remainder == 0) ? 0 : (divisor - remainder);
    
    // อัปเดตคำตอบ: เปรียบเทียบค่าเดิม กับ (จำนวนครั้งบวก + จำนวนครั้งคูณ)
    min_ops = min(min_ops, i + j);
}
```
---

## 3. ตัวอย่าง Test Case พร้อม Step

### Input

```
255
```
### Visual Step

```
Step 1: เริ่มต้นที่ 255
Binary:  00000000 00000000 11111111  (ค่า 255)
Target:  ต้องการทำให้เป็น 0 mod 2^24 
         (คือการดันเลข 1 ให้หลุดขอบซ้ายไป หรือทำให้เลขข้างหลังเป็น 0 ทั้งหมด)

Step 2: ตัดสินใจ "บวก 1" (Add Operation: 1 ครั้ง)
Calculation: 255 + 1 = 256
Binary:  00000000 00000001 00000000  (ค่า 256)
                       ^
                       สังเกตว่าเลข 1 อยู่ที่ตำแหน่งบิตที่ 8

Step 3: ทำการ "คูณ 2" ไปเรื่อยๆ เพื่อดันเลข 1 นี้ออกไปทางซ้าย (Shift Operations)
พื้นที่เก็บข้อมูลมีขนาด 24 บิต (Mod 2^24)

Current: ... 00000001 00000000  (Bit 8)
Shift 1: ... 00000010 00000000  (Bit 9)
Shift 2: ... 00000100 00000000  (Bit 10)
...
Shift 16:... 1 00000000 00000000 (Bit 24) -> หลุดขอบ Loop Modulo!

Result: กลายเป็น 0 (ในระบบ Modulo 2^24)

สรุปจำนวนครั้ง:
1 (จากการบวก) + 16 (จากการคูณ/Shift) = 17 ครั้ง

```

### Output

```
17
```

---

## 4. อื่น ๆ

* **Time Complexity**

  * Big-O: `O(1)`
  * Big-Θ: `Θ(1)`

### เฉลยโค้ด

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

int main() {
    long long x;
    cin >> x;

    if (x == 0) {
        cout << 0 << endl;
        return 0;
    }

    int min_ops = 24;
    const int MOD_VAL = 16777216;

    for (int j = 0; j <= 24; j++) {
        int divisor = 1 << (24 - j); 
        int remainder = x % divisor;
        int i = (remainder == 0) ? 0 : (divisor - remainder);
        min_ops = min(min_ops, i + j);
    }

    cout << min_ops << endl;
    return 0;
}
```