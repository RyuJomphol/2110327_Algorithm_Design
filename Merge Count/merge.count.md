# Merge Count

## 1. วิเคราะห์โจทย์

โจทย์ข้อนี้เป็นประเภท **Constructive Algorithm** (การสร้างตัวอย่างผลลัพธ์จากเงื่อนไขที่กำหนด) และ **Reverse Engineering** (วิศวกรรมย้อนรอย)

**เงื่อนไขหลักของโจทย์:**
* ปกติ Merge Sort จะแบ่งข้อมูลไปเรื่อยๆ จนเหลือ 1 ตัว
* แต่ Merge Sort ในโจทย์นี้มี "ทางลัด" (Optimization): **"ถ้าข้อมูลในช่วง `[l, r)` เรียงลำดับอยู่แล้ว ให้ return ทันที"** (นับเป็น 1 การเรียก)
* ถ้าไม่เรียง จึงจะแบ่งครึ่ง (`mid`) แล้วเรียก `mergesort` ซ้ายและขวา (นับเพิ่มอีก 2 การเรียก)
* **เป้าหมาย:** สร้าง Array ขนาด $n$ ที่ทำให้เกิดการเรียกฟังก์ชัน `mergesort` รวมทั้งหมด $k$ ครั้งพอดี

**ตรรกะในการแก้ปัญหา:**
* **จุดเริ่มต้น (Best Case):** ถ้าเราใส่ Array ที่เรียงเลขไว้แล้ว (เช่น `1 2 3 ... n`) ฟังก์ชันจะถูกเรียกแค่ 1 ครั้ง แล้วจบเลย
* **การเพิ่มจำนวนครั้ง:** หากเราต้องการให้เรียกมากกว่า 1 ครั้ง เราต้องทำให้ Array **"ไม่เรียงลำดับ"** เพื่อบังคับให้ฟังก์ชันแบ่งตัว (Split) ลงไป
* **กฎเลขคี่:** การแบ่ง 1 ครั้ง จะเกิดการเรียกลูกซ้าย 1 ครั้ง และลูกขวา 1 ครั้งเสมอ ดังนั้นจำนวนการเรียกจะเพิ่มทีละ 2
  * สูตร: $\text{Total Calls} = 1 + 2 \times (\text{จำนวนครั้งที่ Split})
$
  * ดังนั้น $k$ **ต้องเป็นเลขคี่เสมอ** ถ้า $k$ เป็นเลขคู่ จะไม่มีทางทำได้ (ตอบ -1)
* **ขอบเขตสูงสุด:** การเรียกมากที่สุดเกิดขึ้นเมื่อแบ่งจนเหลือตัวเดียวทุกตัว ($2n - 1$ ครั้ง) ถ้า $k$ มากกว่านี้ก็ทำไม่ได้ (ตอบ -1)
* **กลยุทธ์ (Strategy):**
  * เริ่มจาก Array ที่เรียงลำดับ `[1, 2, ..., n]`
  * จำลองการแบ่งแบบ Merge Sort ลงไป
  * ถ้าจำนวนครั้งที่เรียก (`call_function`) ยังไม่ถึง $k$:
    * ทำการ **สลับค่า (Swap)** ตัวเลขที่อยู่ตรงรอยต่อระหว่างฝั่งซ้ายและขวา (`mid-1` กับ `mid`) เพื่อทำลายความเรียงลำดับของช่วงนั้น ทำให้ Merge Sort จำเป็นต้องเรียกต่อ
    * บวกจำนวนครั้งเพิ่ม 2
    * เรียกฟังก์ชันย่อยลงไปทำต่อทั้งซ้ายและขวา

---

## 2. แนวคิดหลัก
โค้ดนี้ใช้เทคนิค **Recursion** เพื่อสร้างสถานการณ์ที่ "ไม่เรียงลำดับ" ตามจำนวนที่ต้องการ

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int n, k;
int call_function = 1; // เริ่มต้นนับ 1 เสมอ (สำหรับการเรียกครั้งแรกสุดที่ root)
vector<int> v;

// ฟังก์ชันสำหรับสร้างความไม่เรียงลำดับ
void gen_unsort(int left, int right) {
    // Base Case: 
    // 1. ถ้าจำนวนการเรียกครบ k ครั้งแล้ว (หรือเกิน) ให้หยุด
    // 2. ถ้าช่วงข้อมูลเหลือแค่ 1 ตัว (right - left <= 1) แบ่งต่อไม่ได้แล้ว ให้หยุด
    if (call_function >= k || right - left <= 1) {
        return;
    }

    call_function += 2; // ถ้ายังไม่ครบ เราจะบังคับแบ่ง จึงบวกเพิ่ม 2 (ซ้าย 1 + ขวา 1)
    int middle = (left + right) / 2;
    
    // หัวใจสำคัญ: สลับค่าตรงกลาง
    // การสลับ v[middle - 1] กับ v[middle] รับประกันว่าช่วง [left, right) 
    // จะไม่เรียงลำดับ (เพราะตัวซ้ายดันมากกว่าตัวขวา) 
    // ทำให้ Merge Sort ตามโจทย์ต้องทำงานต่อ
    swap(v[middle - 1], v[middle]);

    // ทำซ้ำกับลูกฝั่งซ้ายและขวา
    gen_unsort(left, middle);
    gen_unsort(middle, right);
}

int main() {
    // การตั้งค่า I/O ให้เร็วขึ้น
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> n >> k;
    v.resize(n);
    
    // ตรวจสอบเงื่อนไขความเป็นไปไม่ได้
    // 1. k เป็นเลขคู่ (เป็นไปไม่ได้ตามทฤษฎี)
    // 2. k มากกว่า 2n-1 (เกินจำนวนโหนดสูงสุดของต้นไม้ Merge Sort)
    if (k % 2 == 0 || k > 2 * n - 1) {
        cout << "-1" << endl;
        return 0;
    }

    // เริ่มต้นด้วย Array ที่เรียงลำดับแล้ว 1 ถึง n
    for (int i = 0; i < n; i++) {
        v[i] = i + 1;
    }

    // เรียกฟังก์ชันเพื่อสลับค่าให้ได้จำนวน call ตาม k
    gen_unsort(0, n);

    // แสดงผลลัพธ์
    for (int i = 0; i < n; i++) {
        cout << v[i] << " ";
    }
}
```

## 3. ตัวอย่าง Test Case

### Input

```
3 3
```
**ข้อมูลนำเข้า (Input)**
* $n = 3$ (สร้าง Array ขนาด 3)
* $k = 3$ (ต้องการให้ Merge Sort เรียก 3 ครั้ง)

**Initial State:** `v = [1, 2, 3]`, `call_function = 1`

**Step-by-Step Simulation:**
* เรียก `gen_unsort(0, 3)`
  * เงื่อนไข: `call_function (1) < k (3)` และช่วงกว้าง `3-0 > 1` → **ทำต่อ**
  * บวก `call_function`: $1 + 2 = 3$ (ตอนนี้ครบ $k$ แล้ว)
  * คำนวณ `middle`: $(0+3)/2 = 1$
  * **Swap:** `v[middle-1]` กับ `v[middle]` คือ `v[0]` กับ `v[1]`
    * `[1, 2, 3]` $\rightarrow$ `[2, 1, 3]`
  * **Recursive Call 1 (ซ้าย):** `gen_unsort(0, 1)`
    * เงื่อนไข: `call_function (3) >= k (3)` → **Return (หยุด)**
  * **Recursive Call 2 (ขวา):** `gen_unsort(1, 3)`
    * เงื่อนไข: `call_function (3) >= k (3)` → **Return (หยุด)**

**Visual Step**
```
สถานะเริ่มต้น: [1, 2, 3]
เป้าหมาย k: 3

      [0, 3) -> ช่วง index 0 ถึง 2 (ค่า 1, 2, 3)
     /      \
   [0,1)   [1,3)
  (ค่า 1)  (ค่า 2,3)

---------------------------------------------------

การทำงานของ gen_unsort(0, 3):
1. call_function = 1 (ยังไม่ถึง 3) -> เพิ่มเป็น 3
2. หาจุดแบ่ง (mid = 1)
3. SWAP ข้อมูลที่รอยต่อ! (v[0] กับ v[1])
   Array เปลี่ยนจาก [1, 2, 3] เป็น [2, 1, 3]
                    ^  ^
                    สลับ

4. เรียกลูกซ้าย gen_unsort(0, 1) -> call_function (3) >= k -> หยุด
5. เรียกลูกขวา gen_unsort(1, 3) -> call_function (3) >= k -> หยุด

---------------------------------------------------

ผลลัพธ์ [2, 1, 3] เมื่อนำไปรัน Merge Sort ตามโจทย์:
- รอบที่ 1: ตรวจ [2, 1, 3] เรียงไหม? -> ไม่ (2 > 1) -> เรียกซ้าย, ขวา (Call +2)
- รอบที่ 2 (ซ้าย): [2] เรียงไหม? -> ใช่ (มีตัวเดียว) -> Return
- รอบที่ 3 (ขวา): [1, 3] เรียงไหม? -> ใช่ (1 < 3) -> Return
รวม = 1 (เริ่ม) + 2 (แยก) = 3 ครั้ง (ตรงตามโจทย์!)
```

### Output

```
2 1 3
```

---

## 4. อื่น ๆ

* **Time Complexity**

  * Big-O: `O(N)`
  * Big-Θ: `Θ(N)`

### เฉลยโค้ด

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int n,k;
int call_function = 1;
vector<int> v;

void gen_unsort(int left , int right) {
    if (call_function >= k || right - left <= 1) {
        return;
    }

    call_function += 2;
    int middle = (left + right) / 2;
    
    swap(v[middle - 1] , v[middle]);

    gen_unsort(left , middle);
    gen_unsort(middle , right);
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> n >> k;
    v.resize(n);
    
    if (k % 2 == 0 || k > 2*n-1) {
        cout << "-1" << endl;
        return 0;
    }

    for (int i = 0 ; i < n ; i++) {
        v[i] = i + 1;
    }

    gen_unsort(0, n);

    for (int i = 0 ; i < n ; i++) {
        cout << v[i] << " ";
    }
}
```